<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation · Cxx.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Cxx.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Implementation</a><ul class="internal"><li><a class="tocitem" href="#llvmcall-1"><span><code>llvmcall</code></span></a></li><li><a class="tocitem" href="#The-@cxx-macro-1"><span>The <code>@cxx</code> macro</span></a></li><li><a class="tocitem" href="#Staged-functions-1"><span>Staged functions</span></a></li><li><a class="tocitem" href="#Implementation-of-the-@cxx-macro-1"><span>Implementation of the <code>@cxx</code> macro</span></a></li></ul></li><li><a class="tocitem" href="../repl/">C++ REPL</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Implementation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaInterop/Cxx.jl/blob/master/docs/src/implementation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="How-it-Works:-A-High-Level-Overview-1"><a class="docs-heading-anchor" href="#How-it-Works:-A-High-Level-Overview-1">How it Works: A High Level Overview</a><a class="docs-heading-anchor-permalink" href="#How-it-Works:-A-High-Level-Overview-1" title="Permalink"></a></h1><p>The two primary Julia features that enable Cxx.jl to work are <code>llvmcall</code> and staged functions.</p><h2 id="llvmcall-1"><a class="docs-heading-anchor" href="#llvmcall-1"><code>llvmcall</code></a><a class="docs-heading-anchor-permalink" href="#llvmcall-1" title="Permalink"></a></h2><p><code>llvmcall</code> allows the user to pass in an LLVM IR expression which will then be embedded directly in the Julia expressions. This functionality could be considered the &quot;inline assembly&quot; equivalent for Julia. However, since all optimizations are run after <code>llvmcall</code> IR has been inlined into the Julia IR, all LLVM optimizations such as constant propagation, dead code elimination, etc. are applied across both sources of IR, eliminating a common inefficiency of using inline (machine code) assembly.</p><p>The primary <code>llvmcall</code> syntax is as follows (reminiscent of the <code>ccall</code> syntax):</p><pre><code class="language-none">llvmcall(&quot;&quot;&quot;%3 = add i32 %1, %0
             ret i32 %3         &quot;&quot;&quot;, Int32, (Int32, Int32), x, y)

         \________________________/ \_____/ \____________/ \___/
              Input LLVM IR            |     Argument Tuple  |
                                   Return Type            Argument</code></pre><p>Behind the scenes, LLVM will take the IR and wrap it in an LLVM function with the given return type and argument types. To call this function, Julia does the same argument translation it would for a <code>ccall</code> (e.g. unboxing <code>x</code> and <code>y</code> if necessary). Afterwards, the resulting call instruction is inlined.</p><p>In this package, however, we use the second form of <code>llvmcall</code>, which differs from the first in that the IR argument is not a string, but a <code>Ptr{Cvoid}</code>. In this case, Julia will skip the wrapping and proceed straight to argument translation and inlining.</p><p>The underlying idea is thus simple: have Clang generate some LLVM IR in memory and then use the second form of LLVM IR to actually call it.</p><h2 id="The-@cxx-macro-1"><a class="docs-heading-anchor" href="#The-@cxx-macro-1">The <code>@cxx</code> macro</a><a class="docs-heading-anchor-permalink" href="#The-@cxx-macro-1" title="Permalink"></a></h2><p>The <code>@cxx</code> macro (see above for a description of its usage) thus needs to analyze the expression passed to it and generate an equivalent representation as a Clang AST, compile it, and splice the resulting function pointer into <code>llvmcall</code>. In principle, this is quite straightforward. We simply need to match on the appropriate Julia AST and call the appropriate methods in Clang&#39;s Sema instance to generate the expression. And while it can be tricky to figure out what method to call, the real problem with this approach is types. Since C++ has compile time function overloading based on types, we need to know the argument types to call the function with, so we may select the correct to call. However, since <code>@cxx</code> is a macro, it operates on syntax only and, in particular, does not know the types of the expressions that form the parameters of the C++ function.</p><p>The solution to this is to, as always in computing, add an extra layer of indirection.</p><h2 id="Staged-functions-1"><a class="docs-heading-anchor" href="#Staged-functions-1">Staged functions</a><a class="docs-heading-anchor-permalink" href="#Staged-functions-1" title="Permalink"></a></h2><p>Staged functions, also known as generated functions, are similar to macros in that they return expressions rather than values. For example,</p><pre><code class="language-julia">@generated function staged_t1(a, b)
   if a == Int
       return :(a+b)
   else
       return :(a*b)
   end
end
@test staged_t1(1,2) == 3         # a is an Int
@test staged_t1(1.0,0.5) == 0.5   # a is a Float64 (i.e. not an Int)
@test staged_t1(1,0.5) == 1.5     # a is an Int</code></pre><p>Though the example above could have of course been done using regular dispatch, it does illustrate the usage of staged functions: Instead of being passed the values, the staged function is first given the type of the argument and, after some computation, returns an expression that represents the actual body of the function to run.</p><p>An important feature of staged functions is that, though a staged function may be called with abstract types, if the staged function throws an error when passed abstract types, execution of the staged function is delayed until all argument types are known.</p><h2 id="Implementation-of-the-@cxx-macro-1"><a class="docs-heading-anchor" href="#Implementation-of-the-@cxx-macro-1">Implementation of the <code>@cxx</code> macro</a><a class="docs-heading-anchor-permalink" href="#Implementation-of-the-@cxx-macro-1" title="Permalink"></a></h2><p>We can thus see how macros and staged functions fit together. First, <code>@cxx</code> does some syntax transformation to make sure all the required information is available to the staged function, e.g.</p><pre><code class="language-julia-repl">julia&gt; macroexpand(:(@cxx foo(a, b)))
:(cppcall(CppNNS{(:foo,)}(), a, b))</code></pre><p>Here <code>cppcall</code> is the staged function. Note that the name of the function to call was wrapped as the type parameter to a <code>CppNNS</code> type. This is important, because otherwise the staged function would not have access to the function name (since it&#39;s a symbol rather than a value). With this, <code>cppcall</code> will get the function name and the types of the two parameters, which is all it needs to build up the Clang AST. The expression returned by the staged function will then simply be the <code>llvmcall</code> with the appropriate generated LLVM function, though in some cases we need to return some extra code.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../repl/">C++ REPL »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 29 December 2019 09:35">Sunday 29 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
